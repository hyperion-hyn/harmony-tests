package testScript

import (
	"encoding/hex"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/ethereum/go-ethereum/staking/types/restaking"
	"github.com/harmony-one/bls/ffi/go/bls"
	"github.com/hyperion-hyn/hyperion-tf/accounts"
	"github.com/hyperion-hyn/hyperion-tf/config"
	"github.com/hyperion-hyn/hyperion-tf/crypto"
	sdkAccounts "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/accounts"
	crypto2 "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/crypto"
	"github.com/hyperion-hyn/hyperion-tf/extension/go-lib/network/rpc/balances"
	commonRPC "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/network/rpc/common"
	sdkNetworkNonce "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/network/rpc/nonces"
	sdkTxs "github.com/hyperion-hyn/hyperion-tf/extension/go-lib/transactions"
	"github.com/hyperion-hyn/hyperion-tf/extension/go-sdk/pkg/address"
	goSdkCommon "github.com/hyperion-hyn/hyperion-tf/extension/go-sdk/pkg/common"
	"github.com/hyperion-hyn/hyperion-tf/keys"
	"github.com/hyperion-hyn/hyperion-tf/utils"
	"math/big"
	"testing"
)

var (
	privateKey1 = "e73981bdb56865b580ec228979187f4db3171140b0d1506f5eea4737460a6d31"
	//pub: 04C8D8CDA80AA0E6B6D9D35483FF032F488D4152D2FB43DAF507F30C6F49063FE48E6FFD6971B352C711371DFAE2763133A0851A2DA903535E89F4FFF1C7BBA9D2
	//eth: 0x0B85c10A2382C858Ba2B4Acc693f00b1C30599D3
	//hyn: hyn1pwzuzz3rsty93w3tftxxj0cqk8pstxwnz5vrlz
	privateKey2 = "289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032"
	//pub: 047DB227D7094CE215C3A0F57E1BCC732551FE351F94249471934567E0F5DC1BF795962B8CCCB87A2EB56B29FBE37D614E2F4C3C45B789AE4F1F51F4CB21972FFD
	//eth: 0x970E8128AB834E8EAC17Ab8E3812F010678CF791
	//hyn: hyn1ju8gz29tsd8gatqh4w8rsyhszpnceau34xxtja
)

func TestSign(t *testing.T) {
	serverUrl := "http://10.10.1.120:8545"
	chain := goSdkCommon.ChainID{"testnet", big.NewInt(7500)}
	rpcClient, err := commonRPC.NewRPCClient(serverUrl)
	if err != nil {
		t.Errorf("new rpc client err: %s", err)
	}

	account1, err := unlockAccount(privateKey1)
	if err != nil {
		t.Errorf("unlock account1 err: %s", err)
	}
	account2, err := unlockAccount(privateKey2)
	if err != nil {
		t.Errorf("unlock account2 err: %s", err)
	}

	currentNonce1 := sdkNetworkNonce.CurrentNonce(rpcClient, account1.Address)
	currentNonce2 := sdkNetworkNonce.CurrentNonce(rpcClient, account2.Address)
	t.Logf("address1 %s, nonce %d. address2 %s, nonce %d", account1.Address, currentNonce1, account2.Address, currentNonce2)

	balance1, err := balances.GetBalance(rpcClient, account1.Address)
	if err != nil {
		t.Errorf("getBalance account1 err: %s", err)
	}
	balance2, err := balances.GetBalance(rpcClient, account2.Address)
	if err != nil {
		t.Errorf("getBalance account2 err: %s", err)
	}
	t.Logf("balance1 %d, balance2 %d", balance1, balance2)

	amount := common.NewDec(1)
	generatedTx, err := sdkTxs.GenerateTransaction(account1.Address, account2.Address, amount, 21000, common.NewDec(1), currentNonce1, "")
	if err != nil {
		t.Errorf("generate transaction fail %s", err)
	}
	tx, err := sdkTxs.SignTransaction(account1.Keystore, account1.Account, generatedTx, chain.Value)
	if err != nil {
		t.Errorf("SignTransaction fail %s", err)
	}
	signature, err := sdkTxs.EncodeSignature(tx)
	if err != nil {
		t.Errorf("encode signture fail %s", err)
	}
	t.Log(*signature)

	//receiptHash, err := sdkTxs.SendRawTransaction(rpcClient, signature)
	//if err != nil {
	//	t.Errorf("SendRawTransaction fail %s", err)
	//}
	//t.Logf("txhash:%v \n", receiptHash)

	//---------------
	// staking sign
	//---------------
	blsKeys := crypto.GenerateBlsKeys(1, "")
	//rate set
	rate, _ := goSdkCommon.NewDecFromString("0.1")
	maxRate, _ := goSdkCommon.NewDecFromString("0.1")
	maxChangeRate, _ := goSdkCommon.NewDecFromString("0.1")

	//currentNonce := sdkNetworkNonce.CurrentNonce(rpcClient, account1.Address)
	createValidator := restaking.CreateValidator{
		OperatorAddress: account1.Account.Address,
		Description: restaking.Description_{
			Name:            "HarmonyTF_D1_Validator",
			Identity:        "HarmonyTF_D1_Validator1",
			Website:         "https://harmony.one",
			SecurityContact: "validator@somewhere.com",
			Details:         "Validator generated by HarmonyTF",
		},
		CommissionRates: restaking.CommissionRates_{
			Rate:          rate,
			MaxRate:       maxRate,
			MaxChangeRate: maxChangeRate,
		},
		MaxTotalDelegation: common.NewDec(1000000).I,
		SlotPubKey:         *blsKeys[0].ShardPublicKey,
		SlotKeySig:         *blsKeys[0].ShardSignature,
		//SlotKeySig: nil, // todo need revert
	}

	bytes, err := rlp.EncodeToBytes(createValidator)
	if err != nil {
		t.Errorf("stak EncodeToBytes err %s", err)
	}
	t.Logf("encoded statking raw bytes: %s", hex.EncodeToString(bytes))
}

func TestTransferToken(t *testing.T) {
	serverUrl := "http://10.10.1.120:8545"
	chain := goSdkCommon.ChainID{"testnet", big.NewInt(7500)}
	rpcClient, err := commonRPC.NewRPCClient(serverUrl)
	if err != nil {
		t.Errorf("new rpc client err: %s", err)
	}

	account, err := unlockAccount(privateKey1)
	if err != nil {
		t.Errorf("unlock account err: %s", err)
	}
	amount := common.NewDec(10)
	hynAddress := address.ToBech32(common.HexToAddress("0xB02FAe2c4D3C892eCCb3ad788F82a4F410320164"))
	currentNonce := sdkNetworkNonce.CurrentNonce(rpcClient, account.Address)

	generatedTx, err := sdkTxs.GenerateTransaction(account.Address, hynAddress, amount, 21000, common.NewDec(1), currentNonce, "")
	if err != nil {
		t.Errorf("generate transaction fail %s", err)
	}
	tx, err := sdkTxs.SignTransaction(account.Keystore, account.Account, generatedTx, chain.Value)
	if err != nil {
		t.Errorf("SignTransaction fail %s", err)
	}
	signature, err := sdkTxs.EncodeSignature(tx)
	if err != nil {
		t.Errorf("encode signture fail %s", err)
	}

	receiptHash, err := sdkTxs.SendRawTransaction(rpcClient, signature)
	if err != nil {
		t.Errorf("SendRawTransaction fail %s", err)
	}
	t.Logf("txhash:%v \n", receiptHash)
}

func unlockAccount(privateKeyHex string) (retAccount *sdkAccounts.Account, err error) {
	address, err := keys.PrivateKeyToAddress(privateKeyHex)
	if err != nil {
		return nil, err
	}
	keyName := utils.PrefixAddress(config.Configuration.Network.Name, address)
	account, err := accounts.ImportPrivateKeyAccount(privateKeyHex, keyName, address)
	if err != nil {
		return nil, err
	}
	err = account.Unlock()
	if err != nil {
		return nil, err
	}
	return &account, nil
}

func TestRlp(t *testing.T) {
	account, err := unlockAccount(privateKey1)
	if err != nil {
		t.Errorf("address err %s", err)
	}
	t.Log(account.Account.Address)

	rate, _ := goSdkCommon.NewDecFromString("0.1")
	maxRate, _ := goSdkCommon.NewDecFromString("1.1")
	maxChangeRate, _ := goSdkCommon.NewDecFromString("10.1")

	blsPrvBytes, _ := hex.DecodeString("b3a285fa7215bc3fcdda8f2004fece08a173eac85ab2ff7c1fefc5003f58ce34")
	bls, _ := recoverBlsKey(blsPrvBytes)
	entry := restaking.CreateValidator{
		OperatorAddress: account.Account.Address,
		Description: restaking.Description_{
			Name:            "HarmonyTF_D1_Validator",
			Identity:        "HarmonyTF_D1_Validator1",
			Website:         "https://harmony.one",
			SecurityContact: "validator@somewhere.com",
			Details:         "Validator generated by HarmonyTF",
		},
		CommissionRates: restaking.CommissionRates_{
			Rate:          rate,
			MaxRate:       maxRate,
			MaxChangeRate: maxChangeRate,
		},
		MaxTotalDelegation: big.NewInt(10000),
		SlotPubKey:         *bls.ShardPublicKey,
		SlotKeySig:         *bls.ShardSignature,
	}

	t.Logf("d1 %d", rate.I)
	t.Logf("d2 %s", maxRate.I)
	t.Logf("d3 %s", maxChangeRate.I)
	t.Logf("bls1 %s", hex.EncodeToString(bls.ShardPublicKey.Key[:]))
	t.Logf("bls2 %s", hex.EncodeToString(bls.ShardSignature[:]))

	bs, err := rlp.EncodeToBytes(entry)
	if err != nil {
		t.Errorf("encode err %s", err)
	}
	t.Log(hex.EncodeToString(bs))
}

//privateKey2 := "289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032"
//prvKey, _ := crypto.HexToECDSA(privateKey2)
//eciesPrvKey := ecies.ImportECDSA(prvKey)
////print pubkey str
//t.Log(hexutils.BytesToHex(crypto.FromECDSAPub(eciesPrvKey.PublicKey.ExportECDSA())))
////pub key to ether address
//pubKeyByte, err := hex.DecodeString("047DB227D7094CE215C3A0F57E1BCC732551FE351F94249471934567E0F5DC1BF795962B8CCCB87A2EB56B29FBE37D614E2F4C3C45B789AE4F1F51F4CB21972FFD")
//publicKey, err := crypto.UnmarshalPubkey(pubKeyByte)
//t.Log(crypto.PubkeyToAddress(*publicKey).String())

func recoverBlsKey(bytes []uint8) (*crypto2.BLSKey, error) {
	privateKey := bls.SecretKey{}
	err := privateKey.Deserialize(bytes)
	if err != nil {
		return nil, err
	}
	privateKeyHex := privateKey.SerializeToHexStr()

	publicKey := privateKey.GetPublicKey()
	publicKeyHex := publicKey.SerializeToHexStr()

	key := crypto2.BLSKey{
		PrivateKey:    &privateKey,
		PrivateKeyHex: privateKeyHex,
		PublicKey:     publicKey,
		PublicKeyHex:  publicKeyHex,
	}

	err = key.Initialize("")
	if err != nil {
		return nil, err
	}
	return &key, nil
}
